---
phase: 02-creative-library-story-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/db.ts
  - src/types/index.ts
  - src/services/markdown.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Database has tables for library_items, stories, story_items, outlines, ai_configs"
    - "TypeScript types exist for all new entities (LibraryItem, Story, StoryItem, Outline, Scene, AIConfig, Template)"
    - "Markdown service can parse YAML frontmatter and stringify it back"
    - "gray-matter, node-diff3, unified, remark-parse, remark-frontmatter, unist-util-visit, and mdast-util-to-string are installed"
  artifacts:
    - path: "src/services/db.ts"
      provides: "Extended schema with Phase 2 tables"
      contains: "library_items"
    - path: "src/types/index.ts"
      provides: "TypeScript types for library, stories, outlines, AI config"
      contains: "LibraryItem"
    - path: "src/services/markdown.ts"
      provides: "Frontmatter parsing, template rendering, markdown utilities"
      exports: ["parseMarkdown", "stringifyMarkdown"]
  key_links:
    - from: "src/services/markdown.ts"
      to: "gray-matter"
      via: "import"
      pattern: "import matter from 'gray-matter'"
    - from: "src/services/db.ts"
      to: "src/types/index.ts"
      via: "schema matches types"
      pattern: "library_items"
---

<objective>
Extend the database schema, TypeScript types, and install Phase 2 dependencies. Create the markdown service for YAML frontmatter parsing and template management.

Purpose: Everything in Phase 2 depends on these foundational pieces — schema tables for persistence, types for type safety, and the markdown service for the text-first content model.
Output: Extended database, complete type definitions, working markdown parsing service, all Phase 2 npm dependencies installed.
</objective>

<execution_context>
@/home/flight/.claude/get-shit-done/workflows/execute-plan.md
@/home/flight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-context-engine/01-01-SUMMARY.md
@.planning/phases/02-creative-library-story-setup/02-RESEARCH.md
@src/services/db.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Phase 2 dependencies and extend database schema</name>
  <files>package.json, src/services/db.ts</files>
  <action>
Install new npm dependencies:
```bash
npm install gray-matter node-diff3 unified remark-parse remark-frontmatter unist-util-visit mdast-util-to-string remark-gfm
```

Extend `src/services/db.ts` — add new CREATE TABLE statements AFTER the existing ones in initDatabase():

```sql
CREATE TABLE IF NOT EXISTS library_items (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL CHECK(type IN ('character', 'setting', 'theme')),
  name TEXT NOT NULL,
  category TEXT DEFAULT '',
  tags TEXT DEFAULT '[]',
  content TEXT NOT NULL,
  version INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS stories (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  premise TEXT DEFAULT '',
  status TEXT DEFAULT 'setup' CHECK(status IN ('setup', 'outlining', 'writing', 'complete')),
  ai_config_id TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS story_items (
  id TEXT PRIMARY KEY,
  story_id TEXT NOT NULL,
  library_id TEXT NOT NULL,
  forked_from_version INTEGER NOT NULL,
  content TEXT NOT NULL,
  has_local_changes INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (story_id) REFERENCES stories(id),
  FOREIGN KEY (library_id) REFERENCES library_items(id)
);

CREATE TABLE IF NOT EXISTS outlines (
  id TEXT PRIMARY KEY,
  story_id TEXT NOT NULL UNIQUE,
  content TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (story_id) REFERENCES stories(id)
);

CREATE TABLE IF NOT EXISTS ai_configs (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  content TEXT NOT NULL,
  is_global INTEGER DEFAULT 0,
  story_id TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (story_id) REFERENCES stories(id)
);

CREATE TABLE IF NOT EXISTS templates (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL CHECK(type IN ('character', 'setting', 'theme', 'outline', 'ai_config')),
  name TEXT NOT NULL,
  content TEXT NOT NULL,
  is_builtin INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_library_items_type ON library_items(type);
CREATE INDEX IF NOT EXISTS idx_story_items_story ON story_items(story_id);
CREATE INDEX IF NOT EXISTS idx_story_items_library ON story_items(library_id);
CREATE INDEX IF NOT EXISTS idx_outlines_story ON outlines(story_id);
CREATE INDEX IF NOT EXISTS idx_ai_configs_story ON ai_configs(story_id);
CREATE INDEX IF NOT EXISTS idx_templates_type ON templates(type);
```

Also seed default templates for characters and settings after the existing preset seeding logic. Check if templates exist first (like presets do):

Character default template:
```markdown
---
name: ""
role: ""
category: Named
tags: []
traits: []
relationships: []
appearance: ""
voice: ""
backstory: ""
arc_notes: ""
---

# Character Notes

(Write additional notes, backstory details, or scene ideas here)
```

Setting default template:
```markdown
---
name: ""
type: ""
atmosphere: ""
sensory_details: ""
character_associations: []
---

# Setting Notes

(Write additional details, history, or mood descriptions here)
```

Seed a default global AI config:
```markdown
---
name: "Default"
stage: "general"
---

# AI Writing Style

Write in a natural, literary style. Focus on character voice and emotional authenticity. Show rather than tell. Keep dialogue grounded and realistic.

## Tone
- Intimate and observational
- Character-driven
- Slice-of-life warmth

## Avoid
- Purple prose
- Info-dumping
- Breaking character voice
```
  </action>
  <verify>
`npm run build` passes. Database initializes without errors. Check with `npm ls gray-matter node-diff3 unified remark-parse` to confirm dependencies installed.
  </verify>
  <done>All Phase 2 tables exist in schema. Default templates and AI config seeded on first init. All npm dependencies installed and resolvable.</done>
</task>

<task type="auto">
  <name>Task 2: Define TypeScript types and create markdown service</name>
  <files>src/types/index.ts, src/services/markdown.ts</files>
  <action>
Extend `src/types/index.ts` with new type definitions. Add these AFTER the existing types (do not modify existing types):

```typescript
// Library types
export type LibraryItemType = 'character' | 'setting' | 'theme';
export type CharacterCategory = 'POV' | 'Named' | 'Background';

export interface LibraryItem {
  id: string;
  type: LibraryItemType;
  name: string;
  category: string;
  tags: string[];
  content: string; // Full markdown with frontmatter
  version: number;
  created_at: number;
  updated_at: number;
}

// Story types
export type StoryStatus = 'setup' | 'outlining' | 'writing' | 'complete';

export interface Story {
  id: string;
  title: string;
  premise: string;
  status: StoryStatus;
  ai_config_id: string | null;
  created_at: number;
  updated_at: number;
}

// Forked library item within a story
export interface StoryItem {
  id: string;
  story_id: string;
  library_id: string;
  forked_from_version: number;
  content: string;
  has_local_changes: boolean;
  created_at: number;
  updated_at: number;
}

// Outline types
export interface Outline {
  id: string;
  story_id: string;
  content: string; // Markdown outline document
  created_at: number;
  updated_at: number;
}

export interface Scene {
  title: string;
  summary: string;
  characters: string[];
  setting: string;
  mood: string;
  chapter?: string;
}

// AI config types
export interface AIConfig {
  id: string;
  name: string;
  content: string; // Markdown with frontmatter
  is_global: boolean;
  story_id: string | null;
  created_at: number;
  updated_at: number;
}

// Template types
export type TemplateType = 'character' | 'setting' | 'theme' | 'outline' | 'ai_config';

export interface Template {
  id: string;
  type: TemplateType;
  name: string;
  content: string; // Markdown template with frontmatter
  is_builtin: boolean;
  created_at: number;
  updated_at: number;
}

// Frontmatter types (parsed from markdown content)
export interface CharacterFrontmatter {
  name: string;
  role: string;
  category: CharacterCategory;
  tags: string[];
  traits: string[];
  relationships: string[];
  appearance: string;
  voice: string;
  backstory: string;
  arc_notes: string;
}

export interface SettingFrontmatter {
  name: string;
  type: string;
  atmosphere: string;
  sensory_details: string;
  character_associations: string[];
}

export interface AIConfigFrontmatter {
  name: string;
  stage: string;
}

// Marker types for AI expansion
export type MarkerType = 'character' | 'setting' | 'expand' | 'ref' | 'instruct';

export interface AIMarker {
  type: MarkerType;
  value: string;
  start: number;
  end: number;
}

// Merge types
export interface MergeResult {
  success: boolean;
  content: string;
  conflictCount: number;
}

// Library reference (auto-detected in outlines)
export interface LibraryReference {
  type: 'character' | 'setting';
  id: string;
  name: string;
  occurrences: number;
}
```

Create `src/services/markdown.ts`:

```typescript
import matter from 'gray-matter';

/**
 * Parse markdown content with YAML frontmatter.
 * Returns the frontmatter data object and the markdown content body.
 */
export function parseMarkdown<T = Record<string, unknown>>(
  markdown: string
): { data: T; content: string } {
  const result = matter(markdown);
  return {
    data: result.data as T,
    content: result.content
  };
}

/**
 * Stringify frontmatter data and markdown content back into a single string.
 */
export function stringifyMarkdown(
  content: string,
  data: Record<string, unknown>
): string {
  return matter.stringify(content, data);
}

/**
 * Extract the name from a markdown document's frontmatter.
 * Returns empty string if no name field found.
 */
export function extractName(markdown: string): string {
  try {
    const { data } = parseMarkdown<{ name?: string }>(markdown);
    return data.name || '';
  } catch {
    return '';
  }
}

/**
 * Update a single frontmatter field without touching the content body.
 */
export function updateFrontmatterField(
  markdown: string,
  field: string,
  value: unknown
): string {
  const { data, content } = parseMarkdown(markdown);
  return stringifyMarkdown(content, { ...data, [field]: value });
}

/**
 * Detect AI expansion markers in text.
 * Marker syntax: {{type:value}}
 * Types: character, setting, expand, ref, instruct
 */
export function detectMarkers(
  text: string
): Array<{ type: string; value: string; start: number; end: number }> {
  const MARKER_REGEX = /\{\{(\w+):([^}]+)\}\}/g;
  const markers: Array<{ type: string; value: string; start: number; end: number }> = [];
  let match;

  while ((match = MARKER_REGEX.exec(text)) !== null) {
    markers.push({
      type: match[1],
      value: match[2].trim(),
      start: match.index,
      end: match.index + match[0].length
    });
  }

  return markers;
}

/**
 * Replace a marker in text with replacement content.
 */
export function replaceMarker(
  text: string,
  marker: { start: number; end: number },
  replacement: string
): string {
  return text.slice(0, marker.start) + replacement + text.slice(marker.end);
}

/**
 * Escape special regex characters in a string (for safe use in RegExp constructor).
 */
export function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```

Note: gray-matter is a CJS module. If Vite/TypeScript complains about ESM interop, use `import matter from 'gray-matter'` with `esModuleInterop: true` (already set in tsconfig). If it still fails at runtime, the fallback is `const matter = (await import('gray-matter')).default`.
  </action>
  <verify>
`npm run build` passes with no TypeScript errors. Types are importable: check that `import { LibraryItem, Story } from '@/types'` resolves.
  </verify>
  <done>All Phase 2 TypeScript types defined. Markdown service parses frontmatter, stringifies it back, detects markers, and provides utility functions. Build succeeds.</done>
</task>

</tasks>

<verification>
- `npm run build` completes with zero errors
- `npm ls gray-matter node-diff3 unified remark-parse` shows all dependencies installed
- Database schema includes library_items, stories, story_items, outlines, ai_configs, templates tables
- Default templates seeded on init
- TypeScript types importable from `@/types`
- `parseMarkdown` and `stringifyMarkdown` work (verify via build, tested in later plans)
</verification>

<success_criteria>
All Phase 2 database tables, types, dependencies, and markdown service in place. Subsequent plans can import types, use markdown parsing, and query new tables without any setup work.
</success_criteria>

<output>
After completion, create `.planning/phases/02-creative-library-story-setup/02-01-SUMMARY.md`
</output>
