---
phase: 02-creative-library-story-setup
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/stores/story-store.ts
  - src/hooks/use-stories.ts
  - src/hooks/use-forked-content.ts
  - src/services/merge.ts
  - src/components/library/StoryList.tsx
  - src/components/library/StoryList.css
autonomous: true

must_haves:
  truths:
    - "User can create a new story with a title"
    - "User can see a list of stories in the Stories tab"
    - "Adding a library item to a story creates a fork (story-local copy)"
    - "Forked items track which library version they were forked from"
    - "Three-way merge can reconcile library updates with story-local changes"
  artifacts:
    - path: "src/stores/story-store.ts"
      provides: "Zustand store for active story state"
      contains: "useStoryStore"
    - path: "src/hooks/use-stories.ts"
      provides: "CRUD operations for stories"
      exports: ["useStories", "useCreateStory", "useStory"]
    - path: "src/hooks/use-forked-content.ts"
      provides: "Fork creation, update detection, merge operations"
      exports: ["useStoryItems", "useForkLibraryItem", "useCheckForUpdates"]
    - path: "src/services/merge.ts"
      provides: "Three-way merge service using node-diff3"
      exports: ["mergeLibraryUpdate"]
  key_links:
    - from: "src/hooks/use-forked-content.ts"
      to: "src/services/merge.ts"
      via: "merge import"
      pattern: "mergeLibraryUpdate"
    - from: "src/services/merge.ts"
      to: "node-diff3"
      via: "import"
      pattern: "diff3Merge"
---

<objective>
Build story management with the copy-on-write forking system for library reuse. Users can create stories, add library items (which creates story-local forks), and merge library updates using three-way merge.

Purpose: Satisfies LIB-03 (reuse library items across stories with per-story modifications) — the forking/merging system that enables shared creative assets while allowing story-specific customization.
Output: Stories tab, story CRUD, fork-on-use system, three-way merge service, update notification capability.
</objective>

<execution_context>
@/home/flight/.claude/get-shit-done/workflows/execute-plan.md
@/home/flight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-creative-library-story-setup/02-CONTEXT.md
@.planning/phases/02-creative-library-story-setup/02-RESEARCH.md
@.planning/phases/02-creative-library-story-setup/02-01-SUMMARY.md
@src/types/index.ts
@src/services/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Story store, CRUD hooks, and merge service</name>
  <files>src/stores/story-store.ts, src/hooks/use-stories.ts, src/hooks/use-forked-content.ts, src/services/merge.ts</files>
  <action>
Create `src/services/merge.ts` — three-way merge using node-diff3:

```typescript
import { diff3Merge } from 'node-diff3';
import type { MergeResult } from '@/types';
```

Implement `mergeLibraryUpdate(storyVersion: string, libraryBase: string, libraryUpdate: string): MergeResult`:
- Normalize line endings (\r\n → \n) before merge
- Use diff3Merge to perform three-way merge
- Count conflict chunks
- Build merged text with git-style conflict markers (<<<<<<< Story Version / ======= / >>>>>>> Library Update)
- Return { success: boolean (no conflicts), content: string, conflictCount: number }

Per research: if conflict rate > 50%, log a warning suggesting manual merge or version reset.

Create `src/stores/story-store.ts` — Zustand store:

```typescript
interface StoryState {
  activeStoryId: string | null;
  setActiveStory: (id: string | null) => void;
}
```

Plain Zustand, no persist.

Create `src/hooks/use-stories.ts` — TanStack Query hooks:

1. `useStories()` — query all stories ordered by updated_at DESC. Poll every 5s.
2. `useStory(id: string | null)` — query single story by ID. Disabled when null.
3. `useCreateStory()` — mutation: creates story with UUID id, title, status='setup', timestamps.
4. `useUpdateStory()` — mutation: updates title, premise, status, updated_at.
5. `useDeleteStory()` — mutation: deletes story AND all related story_items, outlines, ai_configs.

Create `src/hooks/use-forked-content.ts` — forking and merge hooks:

1. `useStoryItems(storyId: string | null)` — query all story_items for a story. Returns items with their library source info.

2. `useForkLibraryItem()` — mutation that:
   - Takes storyId and libraryItemId
   - Fetches the library item's current content and version
   - Creates a new story_items row with UUID id, forked_from_version = library item's current version, content = copy of library content, has_local_changes = 0
   - Returns the new story_item
   - Invalidates story items query

3. `useCheckForUpdates(storyId: string | null)` — query that:
   - For each story_item in the story, checks if the source library_item has a higher version than forked_from_version
   - Returns array of { storyItem, libraryItem, hasUpdate: boolean }
   - Polls every 30s (infrequent — updates are rare)

4. `useMergeLibraryUpdate()` — mutation that:
   - Takes storyItemId
   - Fetches: story item content (ours), library item at forked_from_version (base — query by library_id and version), library item latest (theirs)
   - Note: for base version, store version snapshots or use the content at fork time. Simplification: store the original content at fork time in a `base_content` column, OR reconstruct from version history. Simpler approach per research: just do the merge with current library version as "theirs" and forked_from_version content would need to be stored. Since we're using copy-on-write, store the base_content at fork time.
   - Actually, the simplest approach: add a `base_content` column to story_items (the content at the time of forking). This gives us the three-way merge inputs: base_content (common ancestor), content (story's modifications), and library_item.content (latest library version).
   - Calls mergeLibraryUpdate(storyItem.content, storyItem.base_content, libraryItem.content)
   - If success (no conflicts): updates story_item content, forked_from_version, clears base_content to latest
   - If conflicts: returns the merged content with conflict markers for user to resolve in textarea

**Important schema adjustment:** Add `base_content TEXT` column to story_items table in db.ts. This stores the library item content at time of forking, needed for three-way merge.
  </action>
  <verify>
`npm run build` passes. Merge service handles clean merges and conflict detection. Hooks are importable.
  </verify>
  <done>Story CRUD works. Forking creates story-local copies with base_content for merge. Three-way merge detects conflicts and produces merged output. Update checking identifies stale forks.</done>
</task>

<task type="auto">
  <name>Task 2: Stories tab UI with list and fork management</name>
  <files>src/components/library/StoryList.tsx, src/components/library/StoryList.css, src/App.tsx</files>
  <action>
Create `src/components/library/StoryList.tsx`:
- Uses `useStories()` to list all stories
- "New Story" button that prompts for title (simple inline text input + create button, not a modal)
- Each story shows: title, status badge, created date
- Click a story → sets activeStoryId in story-store
- When a story is active, show its forked items as a sub-list below the story (expandable)
- Each forked item shows: name, type icon, "update available" badge if hasUpdate is true
- "Add Character" / "Add Setting" buttons within story view to fork library items into the story
- Adding shows a simple dropdown/list of available library items to fork
- Delete story with confirmation

Dark theme styles matching existing component patterns.

Modify `src/App.tsx`:
- Add "Stories" tab to tabs array (insert as first tab — Stories | Characters | Settings)
- Stories tab content: `<StoryList />`
- When a story is active and user clicks a forked item, load it into the textarea with contentId `story-item-{storyItem.id}`
- Show an "Update Available" indicator when forked items have newer library versions
- When user clicks the update indicator, trigger the merge and load the result into textarea

**Tab ordering:** Stories | Characters | Settings (the remaining tabs — Templates and AI Config — will be added in later plans).

Note: Do NOT modify the tabs array for Characters/Settings — those are added in Plan 02-02 which runs in parallel. Instead, this plan adds ONLY the Stories tab. The final tab ordering will be reconciled in the integration plan (02-08) since both plans modify App.tsx. To avoid file conflicts: this task should add the Stories tab definition in a separate section of App.tsx that can be merged cleanly. Alternatively, both 02-02 and 02-03 can define their tabs independently and 02-08 merges them.

**Revised approach to avoid App.tsx conflict:** Do NOT modify App.tsx in this task. Only create the StoryList component. App.tsx tab wiring happens in the integration plan (02-08). Export StoryList as a standalone component.
  </action>
  <verify>
`npm run build` passes. StoryList component renders correctly when imported. Fork and merge operations work end-to-end.
  </verify>
  <done>StoryList component created with story CRUD, fork management, and update detection UI. Ready for integration into App.tsx tabs in Plan 02-08.</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- Three-way merge service handles: clean merge (no conflicts), conflicting merge (markers), line ending normalization
- Story CRUD operations persist to SQLite
- Forking copies library item content and stores base_content
- Update detection correctly identifies when library version > forked_from_version
- StoryList component renders with dark theme styling
</verification>

<success_criteria>
Story management with fork-on-use system operational. Three-way merge handles library updates. LIB-03 requirement (reuse across stories with per-story modifications) satisfied at the data layer. UI integration deferred to Plan 02-08.
</success_criteria>

<output>
After completion, create `.planning/phases/02-creative-library-story-setup/02-03-SUMMARY.md`
</output>
