---
phase: 02-creative-library-story-setup
plan: 07
type: execute
wave: 4
depends_on: ["02-01", "02-02"]
files_modified:
  - src/extensions/codemirror/marker-highlighting.ts
  - src/services/marker-processor.ts
  - src/components/markers/MarkerControls.tsx
  - src/components/markers/MarkerControls.css
autonomous: true

must_haves:
  truths:
    - "AI expansion markers ({{type:value}}) are visually highlighted in the textarea"
    - "User can insert markers in any markdown document"
    - "Process button resolves all markers in the document using library context"
    - "Processing creates a version point before applying changes"
    - "Different marker types are visually distinguished (character, setting, expand, ref, instruct)"
  artifacts:
    - path: "src/extensions/codemirror/marker-highlighting.ts"
      provides: "CodeMirror extension for marker syntax highlighting"
      exports: ["markerHighlighting"]
    - path: "src/services/marker-processor.ts"
      provides: "Marker resolution using LLM and library context"
      exports: ["processAllMarkers"]
    - path: "src/components/markers/MarkerControls.tsx"
      provides: "Process button and marker status UI"
  key_links:
    - from: "src/extensions/codemirror/marker-highlighting.ts"
      to: "@codemirror/view"
      via: "Decoration API"
      pattern: "Decoration.mark"
    - from: "src/services/marker-processor.ts"
      to: "src/services/markdown.ts"
      via: "detectMarkers"
      pattern: "detectMarkers"
    - from: "src/services/marker-processor.ts"
      to: "src/services/llm-client.ts"
      via: "LLM generation for expand/instruct markers"
      pattern: "generateStream\\|generate"
---

<objective>
Build the AI expansion marker system: CodeMirror syntax highlighting for {{type:value}} markers, and a processor that resolves markers using library context and LLM generation.

Purpose: Implements the text-based AI interaction model (from user decisions). Users insert markers to request AI processing — referencing characters, expanding sections, or providing instructions. The "Process" button resolves all markers in a single pass.
Output: Marker highlighting extension, marker processing service, Process button UI.
</objective>

<execution_context>
@/home/flight/.claude/get-shit-done/workflows/execute-plan.md
@/home/flight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-creative-library-story-setup/02-CONTEXT.md
@.planning/phases/02-creative-library-story-setup/02-RESEARCH.md
@.planning/phases/02-creative-library-story-setup/02-01-SUMMARY.md
@.planning/phases/02-creative-library-story-setup/02-02-SUMMARY.md
@src/services/markdown.ts
@src/services/llm-client.ts
@src/components/textarea/EnhancedTextarea.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: CodeMirror marker highlighting extension</name>
  <files>src/extensions/codemirror/marker-highlighting.ts</files>
  <action>
Create `src/extensions/codemirror/marker-highlighting.ts`:

Implement a CodeMirror StateField-based decoration extension that highlights {{type:value}} markers in the editor.

Marker syntax: `{{type:value}}` where type is one of: character, setting, expand, ref, instruct.

Color scheme for marker types (CSS classes):
- `character` → blue (#4a9eff) — reference a character profile
- `setting` → green (#4ade80) — reference a setting
- `expand` → amber (#fbbf24) — expand/elaborate this section
- `ref` → purple (#a78bfa) — generic reference
- `instruct` → red-orange (#fb923c) — instruction to the AI

Implementation approach per research (Pitfall #2 — performance):

Use incremental decoration updates, not full doc reparse on every change:

```typescript
const markerField = StateField.define<DecorationSet>({
  create(state) {
    return findAllMarkers(state.doc);
  },
  update(decorations, tr) {
    if (!tr.docChanged) {
      return decorations.map(tr.changes);
    }
    // Incremental: map existing decorations through changes, then
    // recompute only for changed ranges
    let deco = decorations.map(tr.changes);
    tr.changes.iterChangedRanges((_fromA, _toA, fromB, toB) => {
      // Expand range to full lines for correct boundary detection
      const lineFrom = tr.state.doc.lineAt(fromB);
      const lineTo = tr.state.doc.lineAt(toB);
      // Remove old decorations in changed range
      deco = deco.update({
        filterFrom: lineFrom.from,
        filterTo: lineTo.to,
        filter: () => false
      });
      // Add new decorations for changed range
      const newDecos = findMarkersInRange(tr.state.doc, lineFrom.from, lineTo.to);
      if (newDecos.length > 0) {
        deco = deco.update({ add: newDecos, sort: true });
      }
    });
    return deco;
  },
  provide: f => EditorView.decorations.from(f)
});
```

`findAllMarkers(doc)` — scan entire doc for {{type:value}} patterns, create Decoration.mark for each with type-specific CSS class.

`findMarkersInRange(doc, from, to)` — scan only the given range.

Export `markerHighlighting` as the extension array (StateField + base theme with CSS classes).

Also export a companion `markerTheme` that defines the CSS for marker highlighting:
```typescript
const markerTheme = EditorView.baseTheme({
  '.cm-marker-character': { backgroundColor: 'rgba(74, 158, 255, 0.2)', borderRadius: '3px', padding: '0 2px' },
  '.cm-marker-setting': { backgroundColor: 'rgba(74, 222, 128, 0.2)', borderRadius: '3px', padding: '0 2px' },
  '.cm-marker-expand': { backgroundColor: 'rgba(251, 191, 36, 0.2)', borderRadius: '3px', padding: '0 2px' },
  '.cm-marker-ref': { backgroundColor: 'rgba(167, 139, 250, 0.2)', borderRadius: '3px', padding: '0 2px' },
  '.cm-marker-instruct': { backgroundColor: 'rgba(251, 146, 60, 0.2)', borderRadius: '3px', padding: '0 2px' },
});
```

Export the combined extension: `export const markerHighlighting = [markerField, markerTheme];`
  </action>
  <verify>
`npm run build` passes. Extension is importable. Typing `{{character:Alex}}` in a CodeMirror editor with this extension applied would highlight the marker in blue (verify via build, visual test deferred).
  </verify>
  <done>CodeMirror extension highlights {{type:value}} markers with type-specific colors. Incremental updates avoid full-document reparse on each keystroke.</done>
</task>

<task type="auto">
  <name>Task 2: Marker processor service and controls UI</name>
  <files>src/services/marker-processor.ts, src/components/markers/MarkerControls.tsx, src/components/markers/MarkerControls.css</files>
  <action>
Create `src/services/marker-processor.ts`:

```typescript
import { detectMarkers, replaceMarker } from './markdown';
import type { LibraryItem, AIMarker } from '@/types';
```

Implement `processAllMarkers(content: string, libraryItems: LibraryItem[], llmGenerate: (prompt: string) => Promise<string>): Promise<{ processed: string; resolvedCount: number; changes: Array<{ marker: string; replacement: string }> }>`:

Processing logic for each marker type:
- `character:Name` → look up character by name in libraryItems, replace marker with the character's content (the full markdown profile). If not found, replace with `[Character not found: Name]`.
- `setting:Name` → same for settings.
- `ref:Name` → generic lookup in all library items by name.
- `expand:description` → call llmGenerate with prompt: "Expand the following into a detailed paragraph: {description}. Write in the style of the surrounding context." Include surrounding context (100 chars before/after the marker) in the prompt.
- `instruct:instruction` → call llmGenerate with prompt: "Follow this instruction: {instruction}. Context: {surrounding 200 chars}."

Process markers in REVERSE order (from end of document to start) to preserve positions as replacements change document length.

Track each change: { marker: original marker text, replacement: what it became }.

Per research pitfall #6 (version bloat): this function does NOT create versions — the caller is responsible for creating a single version point before processing and one after.

Create `src/components/markers/MarkerControls.tsx`:

A small control bar component that can be placed near the textarea (will be integrated into the right pane header in Plan 02-08):

1. **Marker count display** — "3 markers detected" based on scanning current textarea content
2. **"Process" button** — triggers marker processing:
   - Creates a version point (pre-processing snapshot)
   - Calls processAllMarkers with current content, library items, and LLM generate function
   - Shows processing indicator
   - On completion, updates textarea content with processed result
   - Creates another version point (post-processing)
   - Shows summary: "Resolved 3 markers"
3. **"Preview" option** — per research pitfall #6, show what will change before committing
   - Shows a simple list of marker → replacement pairs
   - "Accept" applies changes, "Cancel" discards
4. **Insert marker buttons** — quick-insert dropdown with marker types:
   - "Insert Character Ref" → inserts `{{character:}}` and positions cursor inside
   - "Insert Setting Ref" → `{{setting:}}`
   - "Insert Expand" → `{{expand:}}`
   - "Insert Instruction" → `{{instruct:}}`

Style: dark theme, compact bar. Process button is primary-styled (blue accent). Marker count uses subtle text.

The component needs access to:
- Current textarea content (passed as prop or via a shared store)
- Library items (via useLibraryItems hook)
- LLM generation function (via settings store + llm-client)
- A way to update textarea content (callback prop)
  </action>
  <verify>
`npm run build` passes. MarkerControls renders with process button and insert options. processAllMarkers correctly resolves character/setting references and generates LLM content for expand/instruct.
  </verify>
  <done>Marker processing resolves all marker types: character/setting lookups from library, expand/instruct via LLM. Process button with preview mode prevents accidental changes. Version points created around processing. MarkerControls UI provides process button and quick-insert options.</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- Marker highlighting: {{character:Alex}} renders with blue background in CodeMirror
- Marker detection: correctly identifies all marker types in text
- Marker processing: character/setting markers resolve to library content
- Marker processing: expand/instruct markers call LLM and insert response
- Preview mode shows changes before applying
- Version points created before and after processing
</verification>

<success_criteria>
AI expansion markers visually highlighted in textarea. Process button resolves all markers using library context and LLM. Preview mode lets users review before accepting. Text-based AI interaction model fully operational.
</success_criteria>

<output>
After completion, create `.planning/phases/02-creative-library-story-setup/02-07-SUMMARY.md`
</output>
